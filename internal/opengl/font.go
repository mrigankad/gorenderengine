package opengl

import (
	"fmt"
	"unsafe"

	gl "github.com/go-gl/gl/v4.1-core/gl"

	"render-engine/core"
	"render-engine/math"
)

// fontBitmap is a public-domain 8×8 bitmap font covering ASCII 32–127 (96 chars).
// Indexed as fontBitmap[charIndex*8 + row]; bit 7 (MSB) = leftmost pixel, row 0 = top.
var fontBitmap = [96 * 8]byte{
	// SP (32)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// ! (33)
	0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,
	// " (34)
	0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// # (35)
	0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00,
	// $ (36)
	0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00,
	// % (37)
	0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00,
	// & (38)
	0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00,
	// ' (39)
	0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	// ( (40)
	0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00,
	// ) (41)
	0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00,
	// * (42)
	0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
	// + (43)
	0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00,
	// , (44)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06,
	// - (45)
	0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
	// . (46)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00,
	// / (47)
	0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00,
	// 0 (48)
	0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,
	// 1 (49)
	0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00,
	// 2 (50)
	0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00,
	// 3 (51)
	0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00,
	// 4 (52)
	0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00,
	// 5 (53)
	0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00,
	// 6 (54)
	0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00,
	// 7 (55)
	0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00,
	// 8 (56)
	0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00,
	// 9 (57)
	0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00,
	// : (58)
	0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00,
	// ; (59)
	0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06,
	// < (60)
	0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00,
	// = (61)
	0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00,
	// > (62)
	0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,
	// ? (63)
	0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00,
	// @ (64)
	0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00,
	// A (65)
	0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00,
	// B (66)
	0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00,
	// C (67)
	0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00,
	// D (68)
	0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00,
	// E (69)
	0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00,
	// F (70)
	0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00,
	// G (71)
	0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00,
	// H (72)
	0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00,
	// I (73)
	0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,
	// J (74)
	0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00,
	// K (75)
	0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00,
	// L (76)
	0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00,
	// M (77)
	0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00,
	// N (78)
	0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00,
	// O (79)
	0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00,
	// P (80)
	0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00,
	// Q (81)
	0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00,
	// R (82)
	0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00,
	// S (83)
	0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00,
	// T (84)
	0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,
	// U (85)
	0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00,
	// V (86)
	0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,
	// W (87)
	0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,
	// X (88)
	0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00,
	// Y (89)
	0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00,
	// Z (90)
	0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00,
	// [ (91)
	0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00,
	// \ (92)
	0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00,
	// ] (93)
	0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00,
	// ^ (94)
	0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00,
	// _ (95)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	// ` (96)
	0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	// a (97)
	0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00,
	// b (98)
	0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00,
	// c (99)
	0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00,
	// d (100)
	0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00,
	// e (101)
	0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00,
	// f (102)
	0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00,
	// g (103)
	0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F,
	// h (104)
	0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00,
	// i (105)
	0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,
	// j (106)
	0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E,
	// k (107)
	0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00,
	// l (108)
	0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,
	// m (109)
	0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00,
	// n (110)
	0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00,
	// o (111)
	0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00,
	// p (112)
	0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F,
	// q (113)
	0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78,
	// r (114)
	0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00,
	// s (115)
	0x00, 0x00, 0x1E, 0x03, 0x1E, 0x30, 0x1F, 0x00,
	// t (116)
	0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00,
	// u (117)
	0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00,
	// v (118)
	0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,
	// w (119)
	0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00,
	// x (120)
	0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00,
	// y (121)
	0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F,
	// z (122)
	0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00,
	// { (123)
	0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00,
	// | (124)
	0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
	// } (125)
	0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00,
	// ~ (126)
	0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// DEL (127)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}

// ── Text shaders ──────────────────────────────────────────────────────────────

const textVertSrc = `
#version 410 core
layout(location = 0) in vec2 inPos;
layout(location = 1) in vec2 inUV;

uniform mat4 ortho;

out vec2 fragUV;

void main() {
    gl_Position = ortho * vec4(inPos, 0.0, 1.0);
    fragUV = inUV;
}
` + "\x00"

const textFragSrc = `
#version 410 core
in vec2 fragUV;
out vec4 outColor;

uniform sampler2D fontAtlas;
uniform vec4 textColor;

void main() {
    float alpha = texture(fontAtlas, fragUV).r;
    outColor = vec4(textColor.rgb, textColor.a * alpha);
}
` + "\x00"

// ── TextRenderer ──────────────────────────────────────────────────────────────

// TextRenderer renders ASCII text as 2D screen-space quads using the embedded
// 8×8 bitmap font. It is created lazily by Renderer.DrawText on first use.
type TextRenderer struct {
	prog     uint32
	vao      uint32
	vbo      uint32
	atlas    uint32 // GL_RED 768×8 texture: 96 chars × 8px wide, 8px tall
	orthoLoc int32
	atlasLoc int32
	colorLoc int32
	vboCap   int // capacity in vertices
}

// buildFontAtlas expands the compact fontBitmap into a 768×8 GL_RED pixel array.
// Row 0 of the output array = GL texture bottom (v=0), which is bitmap row 0 (visual top of glyph).
func buildFontAtlas() [768 * 8]byte {
	var pixels [768 * 8]byte
	for idx := 0; idx < 96; idx++ {
		for bitmapRow := 0; bitmapRow < 8; bitmapRow++ {
			rowByte := fontBitmap[idx*8+bitmapRow]
			for bit := 0; bit < 8; bit++ {
				x := idx*8 + bit
				if rowByte&(0x80>>uint(bit)) != 0 {
					pixels[bitmapRow*768+x] = 255
				}
			}
		}
	}
	return pixels
}

// newTextRenderer compiles the text shader and uploads the font atlas to the GPU.
func newTextRenderer() (*TextRenderer, error) {
	prog, err := newProgram(textVertSrc, textFragSrc)
	if err != nil {
		return nil, fmt.Errorf("text shader: %w", err)
	}

	// Build and upload 768×8 GL_RED atlas texture
	pixels := buildFontAtlas()
	var atlas uint32
	gl.GenTextures(1, &atlas)
	gl.BindTexture(gl.TEXTURE_2D, atlas)
	gl.PixelStorei(gl.UNPACK_ALIGNMENT, 1)
	gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RED, 768, 8, 0, gl.RED, gl.UNSIGNED_BYTE, gl.Ptr(pixels[:]))
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
	gl.BindTexture(gl.TEXTURE_2D, 0)

	// Build VAO/VBO — each vertex is pos(2) + uv(2) = 4 float32
	var vao, vbo uint32
	gl.GenVertexArrays(1, &vao)
	gl.GenBuffers(1, &vbo)

	gl.BindVertexArray(vao)
	gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
	const stride = int32(4 * 4) // 4 float32 × 4 bytes
	gl.EnableVertexAttribArray(0)
	gl.VertexAttribPointer(0, 2, gl.FLOAT, false, stride, gl.PtrOffset(0))  // pos
	gl.EnableVertexAttribArray(1)
	gl.VertexAttribPointer(1, 2, gl.FLOAT, false, stride, gl.PtrOffset(8)) // uv
	gl.BindVertexArray(0)

	tr := &TextRenderer{
		prog:     prog,
		vao:      vao,
		vbo:      vbo,
		atlas:    atlas,
		orthoLoc: gl.GetUniformLocation(prog, gl.Str("ortho\x00")),
		atlasLoc: gl.GetUniformLocation(prog, gl.Str("fontAtlas\x00")),
		colorLoc: gl.GetUniformLocation(prog, gl.Str("textColor\x00")),
	}
	gl.UseProgram(prog)
	gl.Uniform1i(tr.atlasLoc, 0)
	return tr, nil
}

// draw renders text at screen position (startX, startY) in the given color.
// scale multiplies the base 8×8 character size. '\n' advances to the next line.
// screenW/screenH define the orthographic projection extent (top-left origin).
func (tr *TextRenderer) draw(text string, startX, startY, scale float32, color core.Color, screenW, screenH float32) {
	if len(text) == 0 {
		return
	}

	const atlasW = 768.0
	charW := 8.0 * scale
	charH := 8.0 * scale

	// Build quad buffer: 6 vertices × 4 floats per printable character
	buf := make([]float32, 0, len(text)*6*4)
	cx, cy := startX, startY

	for _, ch := range text {
		if ch == '\n' {
			cx = startX
			cy += charH
			continue
		}
		if ch < 32 || ch > 127 {
			ch = '?'
		}
		idx := float32(int(ch) - 32)
		u0 := idx * 8.0 / atlasW
		u1 := (idx + 1.0) * 8.0 / atlasW

		x0, y0 := cx, cy
		x1, y1 := cx+charW, cy+charH

		// Triangle 1: tl, bl, br
		buf = append(buf, x0, y0, u0, 0)
		buf = append(buf, x0, y1, u0, 1)
		buf = append(buf, x1, y1, u1, 1)
		// Triangle 2: tl, br, tr
		buf = append(buf, x0, y0, u0, 0)
		buf = append(buf, x1, y1, u1, 1)
		buf = append(buf, x1, y0, u1, 0)

		cx += charW
	}

	vertCount := len(buf) / 4
	if vertCount == 0 {
		return
	}

	// Upload to GPU
	gl.BindBuffer(gl.ARRAY_BUFFER, tr.vbo)
	byteSize := len(buf) * 4
	if vertCount > tr.vboCap {
		gl.BufferData(gl.ARRAY_BUFFER, byteSize, gl.Ptr(buf), gl.DYNAMIC_DRAW)
		tr.vboCap = vertCount
	} else {
		gl.BufferSubData(gl.ARRAY_BUFFER, 0, byteSize, gl.Ptr(buf))
	}
	gl.BindBuffer(gl.ARRAY_BUFFER, 0)

	// Orthographic projection: (0,0) = top-left, y increases downward
	ortho := math.Mat4Orthographic(0, screenW, screenH, 0, -1, 1)

	gl.UseProgram(tr.prog)
	gl.UniformMatrix4fv(tr.orthoLoc, 1, false, (*float32)(unsafe.Pointer(&ortho[0][0])))
	gl.Uniform4f(tr.colorLoc, color.R, color.G, color.B, color.A)

	gl.ActiveTexture(gl.TEXTURE0)
	gl.BindTexture(gl.TEXTURE_2D, tr.atlas)

	// 2D HUD: no depth test, alpha blending
	gl.Disable(gl.DEPTH_TEST)
	gl.Enable(gl.BLEND)
	gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

	gl.BindVertexArray(tr.vao)
	gl.DrawArrays(gl.TRIANGLES, 0, int32(vertCount))
	gl.BindVertexArray(0)

	// Restore depth test; blend disabled by default
	gl.Enable(gl.DEPTH_TEST)
	gl.Disable(gl.BLEND)
}

func (tr *TextRenderer) destroy() {
	gl.DeleteVertexArrays(1, &tr.vao)
	gl.DeleteBuffers(1, &tr.vbo)
	gl.DeleteTextures(1, &tr.atlas)
	gl.DeleteProgram(tr.prog)
}
